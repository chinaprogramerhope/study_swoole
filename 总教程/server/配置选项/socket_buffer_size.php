socket_buffer_size

配置客户端连接的缓存区长度。从1.8.8版本开始swoole底层对于缓存区控制的参数分离成buffer_output_size和socket_buffer_size两项配置。

参数buffer_output_size用于设置单次最大发送长度。socket_buffer_size用于设置客户端连接最大允许占用内存数量。
$server->set([
    'socket_buffer_size' => 128 * 1024 * 1024, // 必须为数字
]);

单位为字节，如128 * 1024 *1024表示每个TCP客户端连接最大允许有128M待发送的数据
默认为2M字节



数据发送缓存区

调整连接发送缓存区的大小。TCP通信有拥塞控制机制，服务器向客户端发送大量数据时，并不能立即发出。这时发送的数据会存放在服务器端的内存缓存区内。此参数可以调整内存缓存区的大小。

如果发送数据过多，客户端阻塞，数据占满缓存区后Server会报如下错误信息：

swFactoryProcess_finish: send failed, session#1 output buffer has been overflowed.

发送缓冲区塞满导致send失败，只会影响当前的客户端，其他客户端不受影响
服务器有大量TCP连接时，最差的情况下将会占用serv->max_connection * buffer_output_size字节的内存

尤其是外围通信的服务器程序，网络通信较慢，如果持续连续发送数据，缓冲区很快就会塞满。发送的数据会全部堆积在Server的内存里。因此此类应用应当从设计上考虑到网络的传输能力，先将消息存入磁盘，等客户端通知服务器已接受完毕后，再发送新的数据。

如视频直播服务，A用户带宽是 100M，1秒内发送10M的数据是完全可以的。B用户带宽只有1M，如果1秒内发送10M的数据，B用户可能需要100秒才能接收完毕。这时数据会全部堆积在服务器内存中。

可以根据数据内容的类型，进行不同的处理。如果是可丢弃的内容，如视频直播等业务，网络差的情况下丢弃一些数据帧完全可以接受。如果内容是不可丢失的，如微信消息，可以先存储到服务器的磁盘中，按照100条消息为一组。当用户接受完这一组消息后，再从磁盘中取出下一组消息发送到客户端。

<?php
/**
 * Created by PhpStorm.
 * User: hanxiaolong
 * Date: 2018/6/7
 * Time: 11:36
 */